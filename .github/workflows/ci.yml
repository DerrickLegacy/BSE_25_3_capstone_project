name: ðŸŸ¢ Node.js React CI (Deployment Gate Pipeline)

# Trigger CI on any branch push and PR to main
on:
  push:
    # IMPORTANT: Explicitly define branches for controlled deployments
    branches: ['staging', 'bse', 'main', '**'] 
  pull_request:
    branches: ['main']

jobs:
  # =========================================
  # 1. BUILD AND TEST JOB (Always runs first)
  # =========================================
  build-and-test:
    runs-on: ubuntu-latest

    env:
      PG_HOST: 127.0.0.1
      PG_PORT: ${{ secrets.PG_PORT }}
      PG_USER: ${{ secrets.PG_USER }}
      PG_PASSWORD: ${{ secrets.PG_PASSWORD }}
      PG_NAME: ${{ secrets.PG_DATABASE }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ secrets.PG_USER }}
          POSTGRES_PASSWORD: ${{ secrets.PG_PASSWORD }}
          POSTGRES_DB: ${{ secrets.PG_DATABASE }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      # 1. Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Generate unique build version
      - name: Set build version
        id: version
        # Use 'main' as default prefix for branches that aren't explicit
        run: |
          VERSION="${{ github.ref_name }}/$(date +'%Y%m%d%H%M%S')-$(git rev-parse --short HEAD)"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Build version: $VERSION"

      # 3. Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # 4. Install backend dependencies
      - name: Install backend dependencies
        run: npm ci

      # 5. Install frontend dependencies
      - name: Install frontend dependencies
        run: npm ci
        working-directory: client

      # 6. Wait for Postgres & Run Migrations
      - name: Wait for Postgres & Run Migrations
        run: |
          sleep 15
          npm run migrate
        working-directory: .

      # 7. Run backend tests
      - name: Run backend tests
        run: npm test
        working-directory: .
        env:
          VERSION: ${{ env.VERSION }}

      # 8. Run frontend tests
      - name: Run frontend tests
        run: npm test
        working-directory: client

      # 9. Run linting for backend (fix)
      - name: Run linting for backend (Fixing)
        run: npm run lint -- --fix
        working-directory: .

      # 10. Run linting for frontend (fix)
      - name: Run linting for frontend (Fixing)
        run: npm run lint -- --fix
        working-directory: client

      # 11. Create version.json for frontend
      - name: Create version.json for frontend
        run: |
          VERSION_CONTENT='{ "version": "${{ env.VERSION }}", "commit": "$(git rev-parse HEAD)", "date": "$(date)" }'
          echo "$VERSION_CONTENT" > client/public/version.json

      # 12. Build frontend
      - name: Build frontend
        run: npm run build
        working-directory: client

  # =========================================
  # 2. STAGING DEPLOYMENT & HEALTH CHECK GATE
  # =========================================
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() && (github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/bse')
    steps:
      - name: ðŸš€ Trigger Deploy Hook (Staging)
        run: |
          echo "Triggering Staging Deployment..."
          if [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "Deploying Staging using Render Action..."
            /usr/bin/render-deploy --service-id ${{ secrets.RENDER_SERVICE_ID }} --api-key ${{ secrets.RENDER_API_KEY }} --github-token ${{ secrets.GITHUB_TOKEN }}
          else
            echo "Deploying to Staging Hook (Validation)..."
            curl -X POST "${{ secrets.RENDER_STAGING_DEPLOY_HOOK }}"
          fi

  health-check-staging:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: success() && github.ref == 'refs/heads/bse'
    
    steps:
      - name: â²ï¸ Wait for Staging Service to become healthy (The Gate)
        id: health_check_script
        env:
          HEALTH_URL: https://${{ secrets.RENDER_STAGING_URL }}/health
          TIMEOUT_SECONDS: 300 # 5 minutes
          POLL_INTERVAL: 10    # Check every 10 seconds
          
        run: |
          echo "Starting STAGING health check for $HEALTH_URL..."
          echo "Waiting 60 seconds for service to become reachable..."
          sleep 60 
          
          START_TIME=$(date +%s)
          
          while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              if [ "$ELAPSED" -ge "$TIMEOUT_SECONDS" ]; then
                  echo "ðŸ”´ Error: Timeout reached. Staging service is not healthy."
                  exit 1 
              fi
              
              STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL")
              
              echo "Time elapsed: ${ELAPSED}s. Status Code: $STATUS_CODE"
              
              if [ "$STATUS_CODE" -eq 200 ]; then
                  echo "âœ… Success! Staging service is healthy."
                  break
              fi
              
              sleep "$POLL_INTERVAL"
          done

  # =========================================
  # 3. PRODUCTION DEPLOYMENT & HEALTH CHECK
  # =========================================
  deploy-prod:
    runs-on: ubuntu-latest
    needs: health-check-staging 
    if: success() && github.ref == 'refs/heads/bse' 
    steps:
      - name: ðŸš€ Trigger Deploy Hook (Production)
        run: |
          echo "Staging Validation Passed. Triggering FINAL Production Deployment..."
          curl -X POST "${{ secrets.RENDER_PROD_DEPLOY_HOOK }}"

  health-check-prod:
    runs-on: ubuntu-latest
    needs: deploy-prod
    if: success() && github.ref == 'refs/heads/bse' 
    
    steps:
      - name: â²ï¸ Wait for Production Service to become healthy
        id: health_check_script
        env:
          HEALTH_URL: https://${{ secrets.RENDER_PROD_URL }}/health
          TIMEOUT_SECONDS: 300
          POLL_INTERVAL: 10
          
        run: |
          echo "Starting PRODUCTION health check for $HEALTH_URL..."
          echo "Waiting 60 seconds for service to become reachable..."
          sleep 60 
          
          START_TIME=$(date +%s)
          
          while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              if [ "$ELAPSED" -ge "$TIMEOUT_SECONDS" ]; then
                  echo "ðŸ”´ Error: Timeout reached. Production service is not healthy."
                  exit 1 
              fi
              
              STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL")
              
              echo "Time elapsed: ${ELAPSED}s. Status Code: $STATUS_CODE"
              
              if [ "$STATUS_CODE" -eq 200 ]; then
                  echo "âœ… Success! Production service is healthy."
                  break
              fi
              
              sleep "$POLL_INTERVAL"
          done
          
  # =========================================
  # 4. ROLLBACK JOBS
  # =========================================
  rollback-staging-on-failure:
    runs-on: ubuntu-latest
    needs: health-check-staging
    
    # Runs ONLY if the staging health-check failed (and we are on the bse branch)
    if: failure() && needs.health-check-staging.result == 'failure' && github.ref == 'refs/heads/bse'
    
    steps:
      - name: ðŸš¨ Fetch Previous Safe Deployment ID (Staging)
        id: fetch_previous
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          # Use the STAGING Service ID here
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }} 
        run: |
          echo "Staging Health check failed. Finding last safe deployment ID for rollback..."
          
          RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            "https://api.render.com/v1/services/$SERVICE_ID/deploys?limit=5")
            
          # DIAGNOSTIC: Check for deployments that successfully built or are currently live
          echo "--- SAFE Deployment IDs Found (Status: 'live' or 'success', Newest to Oldest) ---"
          DEPLOY_IDS=$(echo "$RESPONSE" | jq -r '.[] | select(.status == "live" or .status == "success") | .id')
          echo "$DEPLOY_IDS"
          echo "-----------------------------------------------------------"

          # CRITICAL FIX: We need the SECOND most recent ID, because the NEWEST one will often be marked "success" 
          # (meaning the build finished) even though the health check failed.
          PREVIOUS_DEPLOY_ID=$(echo "$DEPLOY_IDS" | tail -n +2 | head -n 1)
          
          if [ -z "$PREVIOUS_DEPLOY_ID" ]; then
            echo "ðŸ”´ FATAL ERROR: Rollback failed. Could not find a second safe deployment ID in the recent history."
            echo "Ensure your Render service has at least two deployments with a 'live' or 'success' status."
            exit 1
          fi
          
          echo "Found previous SAFE Deployment ID for rollback: $PREVIOUS_DEPLOY_ID"
          echo "PREVIOUS_DEPLOY_ID=$PREVIOUS_DEPLOY_ID" >> $GITHUB_OUTPUT
          

      - name: ðŸ”„ Trigger Render Rollback (Staging)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
          ROLLBACK_ID: ${{ steps.fetch_previous.outputs.PREVIOUS_DEPLOY_ID }}
          
        run: |
          RENDER_URL="https://api.render.com/v1/services/$SERVICE_ID/deploys/$ROLLBACK_ID/rollback"

          echo "Attempting to roll back STAGING to Deployment ID: $ROLLBACK_ID"
          
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            $RENDER_URL)
          
          if echo "$RESPONSE" | grep -q '"error":'; then
              echo "ðŸ”´ Automated API Rollback Failed for Staging. (Render API Error)"
              echo "Response: $RESPONSE"
              exit 1
          else
              echo "âœ… Automated Staging Rollback Request Successful!"
          fi

  rollback-prod-on-failure:
    runs-on: ubuntu-latest
    needs: health-check-prod
    
    # Runs ONLY if the production health-check failed (and we are on the bse branch)
    if: failure() && needs.health-check-prod.result == 'failure' && github.ref == 'refs/heads/bse'
    
    steps:
      - name: ðŸš¨ Fetch Previous Safe Deployment ID (Production)
        id: fetch_previous_prod
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_PROD_SERVICE_ID }} 
        run: |
          echo "Production Health check failed. Finding last safe deployment ID for rollback..."
          
          RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            "https://api.render.com/v1/services/$SERVICE_ID/deploys?limit=5")
            
          # DIAGNOSTIC: Check for deployments that successfully built or are currently live
          echo "--- SAFE Deployment IDs Found (Status: 'live' or 'success', Newest to Oldest) ---"
          DEPLOY_IDS=$(echo "$RESPONSE" | jq -r '.[] | select(.status == "live" or .status == "success") | .id')
          echo "$DEPLOY_IDS"
          echo "-----------------------------------------------------------"

          # CRITICAL FIX: We need the SECOND most recent ID for the same reason as staging.
          PREVIOUS_DEPLOY_ID=$(echo "$DEPLOY_IDS" | tail -n +2 | head -n 1)
          
          if [ -z "$PREVIOUS_DEPLOY_ID" ]; then
            echo "ðŸ”´ FATAL ERROR: Production Rollback failed. Could not find a second safe deployment ID in the recent history."
            echo "Ensure your Production Render service has at least two deployments with a 'live' or 'success' status."
            exit 1
          fi
          
          echo "Found previous SAFE Deployment ID for rollback: $PREVIOUS_DEPLOY_ID"
          echo "PREVIOUS_DEPLOY_ID=$PREVIOUS_DEPLOY_ID" >> $GITHUB_OUTPUT
          

      - name: ðŸ”„ Trigger Render Rollback (Production)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_PROD_SERVICE_ID }}
          ROLLBACK_ID: ${{ steps.fetch_previous_prod.outputs.PREVIOUS_DEPLOY_ID }}
          
        run: |
          RENDER_URL="https://api.render.com/v1/services/$SERVICE_ID/deploys/$ROLLBACK_ID/rollback"

          echo "Attempting to roll back PRODUCTION to Deployment ID: $ROLLBACK_ID"

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            $RENDER_URL)
          
          if echo "$RESPONSE" | grep -q '"error":'; then
              echo "ðŸ”´ Automated API Rollback Failed for Production. (Render API Error)"
              echo "Response: $RESPONSE"
              exit 1
          else
              echo "âœ… Automated Production Rollback Request Successful!"
          fi

name: 🟢 Node.js React CI (Deployment Gate Pipeline)

# Trigger CI on any branch push and PR to main
on:
  push:
    # IMPORTANT: Explicitly define branches for controlled deployments
    branches: ['staging', 'bse', 'main', '**'] 
  pull_request:
    branches: ['main']

jobs:
  # =========================================
  # 1. BUILD AND TEST JOB (Always runs first)
  # =========================================
  build-and-test:
    runs-on: ubuntu-latest

    env:
      PG_HOST: 127.0.0.1
      PG_PORT: ${{ secrets.PG_PORT }}
      PG_USER: ${{ secrets.PG_USER }}
      PG_PASSWORD: ${{ secrets.PG_PASSWORD }}
      PG_NAME: ${{ secrets.PG_DATABASE }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ secrets.PG_USER }}
          POSTGRES_PASSWORD: ${{ secrets.PG_PASSWORD }}
          POSTGRES_DB: ${{ secrets.PG_DATABASE }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      # 1. Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Generate unique build version
      - name: Set build version
        id: version
        # Use 'main' as default prefix for branches that aren't explicit
        run: |
          VERSION="${{ github.ref_name }}/$(date +'%Y%m%d%H%M%S')-$(git rev-parse --short HEAD)"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Build version: $VERSION"

      # 3. Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # 4. Install backend dependencies
      - name: Install backend dependencies
        run: npm ci

      # 5. Install frontend dependencies
      - name: Install frontend dependencies
        run: npm ci
        working-directory: client

      # 6. Wait for Postgres & Run Migrations
      - name: Wait for Postgres & Run Migrations
        run: |
          sleep 15
          npm run migrate
        working-directory: .

      # 7. Run backend tests
      - name: Run backend tests
        run: npm test
        working-directory: .
        env:
          VERSION: ${{ env.VERSION }}

      # 8. Run frontend tests
      - name: Run frontend tests
        run: npm test
        working-directory: client

      # 9. Run linting for backend (fix)
      - name: Run linting for backend (Fixing)
        run: npm run lint -- --fix
        working-directory: .

      # 10. Run linting for frontend (fix)
      - name: Run linting for frontend (Fixing)
        run: npm run lint -- --fix
        working-directory: client

      # 11. Create version.json for frontend
      - name: Create version.json for frontend
        run: |
          VERSION_CONTENT='{ "version": "${{ env.VERSION }}", "commit": "$(git rev-parse HEAD)", "date": "$(date)" }'
          echo "$VERSION_CONTENT" > client/public/version.json

      # 12. Build frontend
      - name: Build frontend
        run: npm run build
        working-directory: client

  # =========================================
  # 2. STAGING DEPLOYMENT & HEALTH CHECK GATE
  # =========================================
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-test
    # This job deploys to the staging service for validation purposes
    if: success() && (github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/bse')
    steps:
      - name: 🚀 Trigger Deploy Hook (Staging)
        run: |
          echo "Triggering Staging Deployment via Deploy Hook..."
          # Note: Use the deploy action for explicit staging branch deploy, or hook if needed
          if [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            # Fallback to the deployment action for the original staging branch logic
            echo "Deploying Staging using Render Action..."
            /usr/bin/render-deploy --service-id ${{ secrets.RENDER_SERVICE_ID }} --api-key ${{ secrets.RENDER_API_KEY }} --github-token ${{ secrets.GITHUB_TOKEN }}
          else
            # Using Hook for bse promotion pipeline validation
            echo "Deploying to Staging Hook (Validation)..."
            curl -X POST "${{ secrets.RENDER_STAGING_DEPLOY_HOOK }}"
          fi


  health-check:
    runs-on: ubuntu-latest
    needs: deploy-staging # Wait until staging deploy is triggered
    if: success() && github.ref == 'refs/heads/bse'
    
    steps:
      - name: ⏲️ Wait for Staging Service to become healthy (The Gate)
        id: health_check_script
        env:
          HEALTH_URL: https://${{ secrets.RENDER_STAGING_URL }}/health
          TIMEOUT_SECONDS: 300 # 5 minutes
          POLL_INTERVAL: 10    # Check every 10 seconds
          
        run: |
          echo "Starting STAGING health check for $HEALTH_URL..."
          # Give DNS/Service time to warm up (Fixes exit code 6)
          echo "Waiting 60 seconds for service to become reachable..."
          sleep 60 
          
          START_TIME=$(date +%s)
          
          while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              if [ "$ELAPSED" -ge "$TIMEOUT_SECONDS" ]; then
                  echo "🔴 Error: Timeout reached. Staging service is not healthy."
                  exit 1 
              fi
              
              STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL")
              
              echo "Time elapsed: ${ELAPSED}s. Status Code: $STATUS_CODE"
              
              # Check for success (200 OK)
              if [ "$STATUS_CODE" -eq 200 ]; then
                  echo "✅ Success! Staging service is healthy."
                  break # Exit the loop successfully
              fi
              
              sleep "$POLL_INTERVAL"
          done

  # =========================================
  # 3. FINAL PRODUCTION DEPLOYMENT (Promotion)
  # =========================================
  deploy-prod-final:
    runs-on: ubuntu-latest
    # CRITICAL: Only run IF the staging health check passed
    needs: health-check 
    if: success() && github.ref == 'refs/heads/bse' 
    steps:
      - name: 🚀 Trigger Deploy Hook (Production)
        run: |
          echo "Staging Validation Passed. Triggering FINAL Production Deployment..."
          curl -X POST "${{ secrets.RENDER_PROD_DEPLOY_HOOK }}"
          
  # =========================================
  # 4. ROLLBACK JOB (Staging Service)
  # =========================================
  rollback-on-failure:
    runs-on: ubuntu-latest
    needs: health-check
    
    # CRITICAL: Runs ONLY if the health-check job failed (and we are on the bse branch)
    if: failure() && needs.health-check.result == 'failure' && github.ref == 'refs/heads/bse'
    
    steps:
      - name: 🚨 Fetch Previous Successful Deployment ID (Staging)
        id: fetch_previous
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          # Use the STAGING Service ID here, as we are rolling back the failed staging deployment
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }} 
        run: |
          echo "Staging Health check failed. Finding last successful deployment ID for rollback..."
          
          RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            "https://api.render.com/v1/services/$SERVICE_ID/deploys?limit=5")
            
          # DIAGNOSTIC: Print the IDs that were successfully built
          echo "--- Successful Deployment IDs Found (Newest to Oldest) ---"
          # We check for a list of successful IDs. If this list has fewer than 2 items, the rollback must fail.
          echo "$RESPONSE" | jq -r '.[] | select(.status == "success") | .id' || true
          echo "-----------------------------------------------------------"

          # FIX: Find all successful IDs, skip the newest one (which is the broken one that completed its build), and take the next one.
          # tail -n +2 skips the first result, head -n 1 takes the new first result.
          PREVIOUS_DEPLOY_ID=$(echo "$RESPONSE" | jq -r '.[] | select(.status == "success") | .id' | tail -n +2 | head -n 1)
          
          if [ -z "$PREVIOUS_DEPLOY_ID" ]; then
            echo "🔴 FATAL ERROR: Rollback failed. Could not find a second 'success' deployment ID in the recent history."
            echo "Ensure your Render service has at least two successfully built versions (even if one is failing the health check)."
            exit 1
          fi
          
          echo "Found previous SAFE Deployment ID for rollback: $PREVIOUS_DEPLOY_ID"
          echo "PREVIOUS_DEPLOY_ID=$PREVIOUS_DEPLOY_ID" >> $GITHUB_OUTPUT
          

      - name: 🔄 Trigger Render Rollback (Staging)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
          ROLLBACK_ID: ${{ steps.fetch_previous.outputs.PREVIOUS_DEPLOY_ID }}
          
        run: |
          RENDER_URL="https://api.render.com/v1/services/$SERVICE_ID/deploys/$ROLLBACK_ID/rollback"

          echo "Attempting to roll back STAGING to Deployment ID: $ROLLBACK_ID"

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            $RENDER_URL)
          
          if echo "$RESPONSE" | grep -q '"error":'; then
              echo "🔴 Automated API Rollback Failed for Staging. (Render API Error)"
              echo "Response: $RESPONSE"
              exit 1
          else
              echo "✅ Automated Staging Rollback Request Successful!"
          fi

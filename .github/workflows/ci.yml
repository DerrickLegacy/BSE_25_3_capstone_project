name: Node.js React CI

# Trigger CI on any branch push and PR to main
on:
  push:
    branches: ['**']
  pull_request:
    branches: ['main']

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    env:
      PG_HOST: 127.0.0.1
      PG_PORT: ${{ secrets.PG_PORT }}
      PG_USER: ${{ secrets.PG_USER }}
      PG_PASSWORD: ${{ secrets.PG_PASSWORD }}
      PG_NAME: ${{ secrets.PG_DATABASE }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ secrets.PG_USER }}
          POSTGRES_PASSWORD: ${{ secrets.PG_PASSWORD }}
          POSTGRES_DB: ${{ secrets.PG_DATABASE }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      # 1. Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Generate unique build version
      - name: Set build version
        id: version
        run: |
          VERSION="staging-$(date +'%Y%m%d%H%M%S')-$(git rev-parse --short HEAD)"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Build version: $VERSION"

      # 3. Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # 4. Install backend dependencies
      - name: Install backend dependencies
        run: npm ci

      # 5. Install frontend dependencies
      - name: Install frontend dependencies
        run: npm ci
        working-directory: client

      # 6. Wait for Postgres
      - name: Wait for Postgres
        run: sleep 15

      # 7. Run database migrations
      - name: Run database migrations
        run: npm run migrate
        working-directory: .

      # 8. Run backend tests (with version)
      - name: Run backend tests
        run: npm test
        working-directory: .
        env:
          VERSION: ${{ env.VERSION }}

      # 9. Run frontend tests
      - name: Run frontend tests
        run: npm test
        working-directory: client

      # 10. Run linting for backend
      - name: Run linting for backend
        run: npm run lint
        working-directory: .

      # 11. Run linting for frontend
      - name: Run linting for frontend
        run: npm run lint
        working-directory: client

      # 12. Create version.json for frontend
      - name: Create version.json for frontend
        run: |
          VERSION="staging-$(date +'%Y%m%d%H%M%S')-$(git rev-parse --short HEAD)"
          echo "{ \"version\": \"${VERSION}\", \"commit\": \"$(git rev-parse HEAD)\", \"date\": \"$(date)\" }" > client/public/version.json
          echo "Build version: $VERSION"

      # 13. Build frontend
      - name: Build frontend
        run: npm run build
        working-directory: client

      # 14. Deploy to Render Staging
      - name: Deploy to Render (Staging)
        if: success() && github.ref == 'refs/heads/staging'
        uses: JorgeLNJunior/render-deploy@v1.4.6
        with:
          service_id: ${{ secrets.RENDER_SERVICE_ID }}
          api_key: ${{ secrets.RENDER_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      #15. Deploy Production
      # - name: Deploy to Render (Production)
      #   if: success() && github.ref == 'refs/heads/bse'
      #   uses: JorgeLNJunior/render-deploy@v1.4.6
      #   with:
      #     service_id: ${{ secrets.RENDER_PROD_SERVICE_ID }}
      #     api_key: ${{ secrets.RENDER_API_KEY }}
      #     github_token: ${{ secrets.GITHUB_TOKEN }}

  deploy-prod:
      runs-on: ubuntu-latest
      needs: build-and-test
      if: success() && github.ref == 'refs/heads/bse' 
      steps:
        # 🚀 NEW DEPLOYMENT STEP: Using curl to hit the Render Deploy Hook
        - name: 🚀 Trigger Deploy Hook (Production)
          run: |
            echo "Triggering Production Deployment via Deploy Hook..."
            curl -X POST "${{ secrets.RENDER_PROD_DEPLOY_HOOK }}"

  # =========================================
  # 2. HEALTH CHECK JOB
  # Uses a native curl script to check the URL, eliminating the need for jakejarvis/wait-for-url
  # =========================================
  health-check:
    runs-on: ubuntu-latest
    needs: build-and-test
    # IMPORTANT: Run if build-and-test succeeded and we are on the staging branch
    if: success() && github.ref == 'refs/heads/bse'
    
    steps:
      - name: ⏲️ Wait for service to become healthy (Native Script)
        id: health_check_script
        env:
          HEALTH_URL: https://${{ secrets.RENDER_STAGING_URL }}/health
          TIMEOUT_SECONDS: 300 # 5 minutes
          POLL_INTERVAL: 10    # Check every 10 seconds
          
        run: |
          echo "Starting health check for $HEALTH_URL..."
          START_TIME=$(date +%s)
          
          while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED=$((CURRENT_TIME - START_TIME))
              
              # 1. Check for timeout
              if [ "$ELAPSED" -ge "$TIMEOUT_SECONDS" ]; then
                  echo "🔴 Error: Timeout reached ($TIMEOUT_SECONDS seconds). Service is not healthy."
                  exit 1 
              fi
              
              # 2. Perform the actual health check request
              # -s: silent, -o /dev/null: discard output, -w "%{http_code}": write only the status code
              STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL")
              
              echo "Time elapsed: ${ELAPSED}s. Status Code: $STATUS_CODE"
              
              # 3. Check for success (200 OK)
              if [ "$STATUS_CODE" -eq 200 ]; then
                  echo "✅ Success! Service is healthy."
                  break # Exit the loop successfully
              fi
              
              # 4. Wait before polling again
              sleep "$POLL_INTERVAL"
          done
  
  # =========================================
  # 3. ROLLBACK JOB
  # Runs ONLY if the health check job failed.
  # =========================================
  rollback-on-failure:
    runs-on: ubuntu-latest
    needs: health-check
    
    # CRITICAL: Runs ONLY if the health-check job failed AND we are on the main branch 
    if: failure() && needs.health-check.result == 'failure' && github.ref == 'refs/heads/bse'
    
    steps:
      - name: 🚨 Fetch Previous Successful Deployment ID
        id: fetch_previous
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
        run: |
          echo "Health check failed. Finding last successful deployment ID..."
          
          # Query Render API for the last successful deployment
          RESPONSE=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            "https://api.render.com/v1/services/$SERVICE_ID/deploys?limit=5")
            
          # Finds the most recent deployment with status "live" (i.e., the last known good version)
          # jq must be available on the runner, which it is by default.
          PREVIOUS_DEPLOY_ID=$(echo "$RESPONSE" | jq -r '.[] | select(.status == "live") | .id' | head -n 1)
          
          if [ -z "$PREVIOUS_DEPLOY_ID" ]; then
            echo "🔴 Error: Could not find a previous 'live' deployment ID for rollback."
            exit 1
          fi
          
          echo "Found previous LIVE deployment ID: $PREVIOUS_DEPLOY_ID"
          echo "PREVIOUS_DEPLOY_ID=$PREVIOUS_DEPLOY_ID" >> $GITHUB_OUTPUT
          

      - name: 🔄 Trigger Render Rollback
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
          ROLLBACK_ID: ${{ steps.fetch_previous.outputs.PREVIOUS_DEPLOY_ID }}
          
        run: |
          # The rollback endpoint URL
          RENDER_URL="https://api.render.com/v1/services/$SERVICE_ID/deploys/$ROLLBACK_ID/rollback"

          echo "Attempting to roll back to Deployment ID: $ROLLBACK_ID"

          # Send the POST request to the Render API to trigger the rollback
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Accept: application/json" \
            $RENDER_URL)
          
          if echo "$RESPONSE" | grep -q '"error":'; then
              echo "🔴 Automated API Rollback Failed."
              echo "Response: $RESPONSE"
              exit 1
          else
              echo "✅ Automated Rollback Request Successful!"
              echo "Render is now deploying the old version."
          fi